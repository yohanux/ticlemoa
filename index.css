<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="index.css">
    <!-- Google Identity Services 라이브러리 추가 -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
  </head>
  <body>
    <div class="navbar">
      <span class="nav-title">티클모아 - 아티클 모아보기</span>
      <span class="nav-login">
        <div id="g_id_onload"
          data-client_id="659949826583-0f71n7kr44grvqrc77qv5iqqmndhl0p0.apps.googleusercontent.com"
          data-context="signin"
          data-ux_mode="popup"
          data-callback="onGoogleSignIn"
          data-auto_prompt="false">
        </div>
        <div class="g_id_signin"
          data-type="standard"
          data-shape="rectangular"
          data-theme="outline"
          data-text="signin_with"
          data-size="medium"
          data-logo_alignment="left">
        </div>
      </span>
    </div>
    <div class="content-container">
      <div class="rss-buttons" id="rss-buttons"></div>
      <div id="rss"></div>
    </div>
    <script>
      // 여러 RSS 피드 URL을 배열로 관리
      const feeds = [
        {
          name: '토스테크',
          url: 'https://toss.tech/rss.xml',
          icon: 'resources/tosstech.png',
          type: 'rss'
        },
        {
          name: '우아한테크블로그',
          url: 'https://techblog.woowahan.com/feed/',
          icon: 'resources/woowahan.png',
          type: 'rss'
        }
      ];

      // 캐시 관리를 위한 객체
      const feedCache = {
        data: {},
        timestamp: {},
        CACHE_DURATION: 5 * 60 * 1000, // 5분

        async get(key) {
          const now = Date.now();
          if (this.data[key] && this.timestamp[key] && 
              (now - this.timestamp[key] < this.CACHE_DURATION)) {
            return this.data[key];
          }
          return null;
        },

        set(key, data) {
          this.data[key] = data;
          this.timestamp[key] = Date.now();
        }
      };

      // 버튼 생성
      const btnContainer = document.getElementById('rss-buttons');
      // 전체 버튼 추가
      const allBtn = document.createElement('button');
      allBtn.textContent = '전체';
      allBtn.onclick = () => selectFeed('all');
      allBtn.classList.add('active');
      btnContainer.appendChild(allBtn);
      feeds.forEach((feed, idx) => {
        const btn = document.createElement('button');
        btn.textContent = feed.name;
        btn.onclick = () => selectFeed(idx);
        btnContainer.appendChild(btn);
      });
      // + 버튼 추가 (맨 우측)
      const plusBtn = document.createElement('button');
      plusBtn.textContent = '+';
      plusBtn.style.fontWeight = 'bold';
      plusBtn.style.fontSize = '1.2em';
      plusBtn.onclick = () => { window.location.href = 'edit.html'; };
      btnContainer.appendChild(plusBtn);

      // XML 문자열을 파싱하는 함수
      function parseXML(xmlText) {
        const parser = new DOMParser();
        const xml = parser.parseFromString(xmlText, 'text/xml');
        
        // Check for parsing errors
        const parserError = xml.querySelector('parsererror');
        if (parserError) {
          throw new Error(`XML parsing error: ${parserError.textContent}`);
        }
        
        return xml;
      }

      // RSS/Atom 피드를 파싱하는 함수
      function parseRSSItems(xml) {
        const items = [];
        const entries = xml.querySelectorAll('item, entry');
        
        entries.forEach(entry => {
          // 제목 파싱
          const title = entry.querySelector('title')?.textContent?.trim() || '';
          
          // 링크 파싱
          let link = '';
          const linkElement = entry.querySelector('link');
          if (linkElement) {
            link = linkElement.textContent?.trim() || linkElement.getAttribute('href')?.trim() || '';
          }
          
          // 설명 파싱
          let description = '';
          const descElement = entry.querySelector('description, content\\:encoded, content');
          if (descElement) {
            description = descElement.textContent?.trim() || '';
          }
          
          // 날짜 파싱
          let pubDate = '';
          const dateElement = entry.querySelector('pubDate, published, dc\\:date');
          if (dateElement) {
            pubDate = dateElement.textContent?.trim() || '';
          }
          
          if (title && link) {
            items.push({ title, link, description, pubDate });
          }
        });
        
        return items;
      }

      // RSS 피드를 가져오는 함수
      async function fetchFeed(feed) {
        try {
          // 캐시 확인
          const cachedData = await feedCache.get(feed.url);
          if (cachedData) {
            console.log(`Using cached data for ${feed.name}`);
            return cachedData;
          }

          console.log(`Fetching feed for ${feed.name}...`);
          
          // YQL을 사용하여 CORS 우회
          const yqlURL = `https://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20xml%20where%20url%3D'${encodeURIComponent(feed.url)}'&format=xml`;
          
          const response = await fetch(yqlURL);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const text = await response.text();
          console.log(`Received data for ${feed.name}`);
          
          // XML 파싱
          const xml = parseXML(text);
          const results = xml.querySelector('results');
          
          if (!results) {
            throw new Error('No results found in YQL response');
          }
          
          // RSS 항목 파싱
          const items = parseRSSItems(results);
          console.log(`Parsed ${items.length} items from ${feed.name}`);
          
          if (items.length === 0) {
            throw new Error('No items found in feed');
          }
          
          // 피드 정보 추가
          const processedItems = items.map(item => ({
            ...item,
            feedName: feed.name,
            feedIcon: feed.icon
          }));
          
          const result = {
            name: feed.name,
            icon: feed.icon,
            items: processedItems
          };
          
          // 결과 캐싱
          feedCache.set(feed.url, result);
          return result;
        } catch (error) {
          console.error(`Error fetching ${feed.name}:`, error);
          // 캐시된 데이터가 있다면 에러 시 캐시된 데이터 반환
          const cachedData = await feedCache.get(feed.url);
          if (cachedData) {
            console.log(`Returning cached data for ${feed.name}`);
            return cachedData;
          }
          return {
            name: feed.name,
            icon: feed.icon,
            items: []
          };
        }
      }

      // 피드 선택 및 표시
      async function selectFeed(idx) {
        // 버튼 active 처리
        Array.from(btnContainer.children).forEach((btn, i) => {
          if(idx === 'all') {
            btn.classList.toggle('active', i === 0);
          } else {
            btn.classList.toggle('active', i === idx + 1);
          }
        });

        const rssContainer = document.getElementById('rss');
        rssContainer.innerHTML = '<div class="loading">불러오는 중...<div class="spinner"></div></div>';

        try {
          if(idx === 'all') {
            console.log('Fetching all feeds...');
            // 모든 피드를 병렬로 fetch
            const results = await Promise.all(feeds.map(feed => fetchFeed(feed)));
            console.log('All feeds results:', results);
            
            const allItems = results.flatMap(feed => feed.items)
              .filter(item => item.pubDate && item.title)
              .sort((a, b) => new Date(b.pubDate) - new Date(a.pubDate));

            if (allItems.length > 0) {
              rssContainer.innerHTML = allItems.map(item => `
                <div class="article-item">
                  <img src="${item.feedIcon}" alt="icon" class="article-icon" onerror="this.src='resources/default-icon.png'">
                  <div class="article-content">
                    <a href="${item.link}" target="_blank" class="article-title">${item.title}</a>
                    <div class="article-date">${item.pubDate ? formatDate(item.pubDate) : ''}</div>
                    ${cleanDescription(item, 'all') ? `<p class='article-desc'>${cleanDescription(item, 'all')}</p>` : ''}
                  </div>
                </div>
              `).join('');
            } else {
              rssContainer.innerHTML = '<div class="error-message">RSS 피드를 불러오는데 실패했습니다. 잠시 후 다시 시도해주세요.</div>';
            }
          } else {
            console.log(`Fetching feed for ${feeds[idx].name}...`);
            const data = await fetchFeed(feeds[idx]);
            console.log(`Feed data:`, data);
            
            if (data.items && data.items.length > 0) {
              rssContainer.innerHTML = data.items.map(item => `
                <div class="article-item">
                  <img src="${feeds[idx].icon}" alt="icon" class="article-icon" onerror="this.src='resources/default-icon.png'">
                  <div class="article-content">
                    <a href="${item.link}" target="_blank" class="article-title">${item.title}</a>
                    <div class="article-date">${item.pubDate ? formatDate(item.pubDate) : ''}</div>
                    ${cleanDescription(item, idx) ? `<p class='article-desc'>${cleanDescription(item, idx)}</p>` : ''}
                  </div>
                </div>
              `).join('');
            } else {
              rssContainer.innerHTML = '<div class="error-message">RSS 피드를 불러오는데 실패했습니다. 잠시 후 다시 시도해주세요.</div>';
            }
          }
        } catch (error) {
          console.error('Error:', error);
          rssContainer.innerHTML = '<div class="error-message">RSS 피드를 불러오는데 실패했습니다. 잠시 후 다시 시도해주세요.</div>';
        }
      }

      function cleanDescription(item, idx) {
        let desc = item.description || '';
        // 우아한테크블로그(woowahan)만 처리
        if ((idx === 'all' && item.feedName === '우아한테크블로그') || (typeof idx === 'number' && feeds[idx].name === '우아한테크블로그')) {
          // 'The post'로 시작하는 부분부터 잘라냄
          const regex = /The post[\s\S]*?first appeared on[\s\S]*?(<[^>]+>|$)/i;
          desc = desc.replace(regex, '');

          // <p>우아한형제들 기술블로그.</p> 또는 <div>우아한형제들 기술블로그.</div> 등 블록 전체 제거
          desc = desc.replace(/<p>\s*우아한형제들 기술블로그\.?(\s|&nbsp;)*<\/p>/gi, '');
          desc = desc.replace(/<div>\s*우아한형제들 기술블로그\.?(\s|&nbsp;)*<\/div>/gi, '');
          // <br> 또는 <br />로만 남은 경우도 제거
          desc = desc.replace(/(우아한형제들 기술블로그\.?\s*)?(<br\s*\/?>)+/gi, '');
          // 남아있는 텍스트에서 우아한형제들 기술블로그.만 남은 경우도 제거
          desc = desc.replace(/우아한형제들 기술블로그\.?/gi, '');

          // 내용이 전부 사라진 경우 빈 문자열로
          if (desc.replace(/(<([^>]+)>)/gi, '').trim() === '') {
            desc = '';
          }
        }
        return desc;
      }

      function formatDate(dateStr) {
        if (!dateStr) return '';
        const d = new Date(dateStr);
        const yyyy = d.getFullYear();
        const mm = String(d.getMonth() + 1).padStart(2, '0');
        const dd = String(d.getDate()).padStart(2, '0');
        return `${yyyy}.${mm}.${dd}`;
      }

      // 구글 로그인 콜백 함수
      function onGoogleSignIn(response) {
        // response.credential에 JWT가 담겨있음
        const jwt = response.credential;
        // JWT를 디코드하거나, 서버로 전달하여 사용자 인증 처리
        // 예시: 사용자 이름 추출
        const payload = JSON.parse(atob(jwt.split('.')[1]));
        alert('환영합니다, ' + payload.name + '님!');
        // 이후 사용자 정보 표시, 로그아웃 등 구현 가능
      }

      // 첫 번째(전체) 피드 기본 표시
      selectFeed('all');
    </script>
  </body>
</html>
